package mutation

import (
	"go/ast"
	"go/token"
)

const {{.LowerName}}MutatorName = "{{.LowerName}}"

// {{.StructName}}Mutator mutates {{.Description}}.
type {{.StructName}}Mutator struct {
}

// Name returns the name of the mutator.
func (m *{{.StructName}}Mutator) Name() string {
	return {{.LowerName}}MutatorName
}

// CanMutate returns true if the node can be mutated by this mutator.
func (m *{{.StructName}}Mutator) CanMutate(node ast.Node) bool {
	// TODO: Implement mutation logic
	return false
}

// Mutate generates mutants for the given node.
func (m *{{.StructName}}Mutator) Mutate(node ast.Node, fset *token.FileSet) []Mutant {
	// TODO: Implement mutation generation
	var mutants []Mutant

	return mutants
}

// Apply applies the mutation to the given AST node.
func (m *{{.StructName}}Mutator) Apply(node ast.Node, mutant Mutant) bool {
	// TODO: Implement mutation application logic
	// Example for different mutation types:
	
	// switch mutant.Type {
	// case "{{.LowerName}}_binary":
	// 	return m.applyBinary(node, mutant)
	// case "{{.LowerName}}_assign":
	// 	return m.applyAssign(node, mutant)
	// }
	
	return false
}

// Helper methods for Apply (add as needed):
//
// func (m *{{.StructName}}Mutator) applyBinary(node ast.Node, mutant Mutant) bool {
// 	if expr, ok := node.(*ast.BinaryExpr); ok {
// 		newOp := m.stringToToken(mutant.Mutated)
// 		if newOp != token.ILLEGAL {
// 			expr.Op = newOp
// 			return true
// 		}
// 	}
// 	return false
// }
//
// func (m *{{.StructName}}Mutator) stringToToken(s string) token.Token {
// 	// TODO: Implement token conversion
// 	return token.ILLEGAL
// }
